# 3D-Discovery
  The goal of this project is to create 2 prototypes to test a 3D Neighbor Discovery Algorithm using line of sight. This will be a proof of concept that the agents can find each in a 3D space. The prototypes are hemispheres whose positions can be moved around in relation to each other. The prototypes use Raspberry Pis to control 16 Irda transceivers. Each prototype uses 5 4:1 muxes to select which transceiver to send or receive on. 1 of the muxes, called mux_prime, is connected to the other four muxes, called mux_seconds, to select between the 16 different transceivers. One of the prototypes, the leader, starts the algorithm by sending data while the other, the follower, begins by listening for data. The prototypes are labeled A and B with A being the leader and B being the follower. 

  The prototypes use plasticine clay balls to hold transceivers at different angles. The clay sits in the center of a wooden circle about 6 inches in diameter. The transceivers are attached to cocktail sticks using double-sided tape which are then attached to the clay. The angle and position of each transceiver was determined using the file code_suman.py which gives theta and phi values for each transceiver on a sphere. Theta is the angle from the x axis on the xy plane while phi is the angle of the transceiver from the z axis. We decided that a hemisphere would be a sufficient proof of concept instead of a full sphere. code_suman.py gave us angles for 35 transceivers so a hemisphere would have 17 or 18 transceivers. We decided instead to use 16 transceivers and have a blind spot in each prototype because otherwise we would have needed another mux. Each transceiver has a number between 0 and 15 and the algorithm iterates through them. The code for the algorithms is written in python. The pi uses the serial port to communicate with the transceivers. The prototypes use 3.3V power and power for each mux and transceiver is supplied by the Raspberry Pis. Every TX pin should be connected to an RX pin and every RX pin should be connected to a TX pin. Each transceiver has an RST pin which should be connected to 3.3V for normal operation. Each mux has a INH pin which should be connected to GND. 
  There is also a small testing stick with another transceiver and raspberry pi. This is runs the program one_trans_handshake_test.py and is used to test the functionality of each individual transceiver. Hold the stick so that its transceiver is facing the transceiver you want to test and run the programs on both pis. 

  In order to execute the algorithm, position the A and B and run the python code on both pis at the same time. If the code is not started at the same time on each, then the agents could get out of sync with each other. The algorithm is a three step handshake. A picks a transceiver and sends "Hello" 5 times. At the same time, B picks a transceiver and listens for "Hello" 5 times. If B receives "Hello" then it will send the confirmation message "H-ACK" 5 times on the same transceiver. After sending "Hello" 5 times, A listens for "H-ACK" 5 times. If A does not receive "H-ACK" then A switches to the next transceiver and restarts. If B does not receive "Hello" then B waits 5 times then switches to the next transceiver. If A receives "H-ACK" then A will send "ACK" 5 times on the same transceiver as a final confirmation. At the same time, B listens for "ACK" 5 times and if B receives "ACK" then the handshake is complete. During each send and receive the algorithm waits for 0.5 seconds to allow time for the signal to be sent and received. The messages are sent 5 times each so that the algorithm works even if one of the signals is noisy or is not received perfectly. The file ID.txt is used to tell the agent whether it is the leader or the follower as well as what transceiver to start searching with. The first line is either "leader" or "follower" while the second line is just the number of the transceiver. Do not press enter after the number.
  
  When positioning A and B, keep in mind that their alignments and which way they are each facing could affect the discovery algorithm. Currently B is attached to a tilting mount and A rests flat on a table. Be careful when moving A because unlike B, the clay is not firmly anchored to the wood and can move around more easily than B can. The wires should be long enough for the agents to move, tilt, and rotate but the wires might still come loose or need adjustments to their length. The wires might also slightly tilt or push around some of the transceivers but the area in which the transceivers can send and receive data is so large that this should not be an issue. The tape attaching the tranceivers to the cocktail sticks might also come loose and need to be replaced.
  When you set up the raspberry pi for this prototype, you need to go into the configurations of the pi and make sure that the serial port is enabled and serial console is disabled. This setting is under Main Menu > Preferences > Raspberry Pi configuration > Interfaces. If serial port is disabled then the python serial class cannot be used and if serial console is enabled then the pi will not receive the correct data from the transceivers.
  The discovery algorithm needs more work to be fully functional for all transceivers.
